#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>

// This file is in the Windows DDK available from Microsoft.
#include <hidsdi.h>
#include <SetupAPI.h>

#include "hid_impl.h"

//#define DEBUG 1 //let meson handle it

#define LZFX_ESIZE      -1      /* Output buffer too small */
#define LZFX_ECORRUPT   -2      /* Invalid data for decompression */
#define LZFX_EARGS      -3      /* Arguments invalid (NULL) */
#define LZFX_HLOG 16
#define LZFX_HSIZE (1 << (LZFX_HLOG))
#define fx_expect_false(expr)  (expr)
#define fx_expect_true(expr)   (expr)
typedef unsigned char u8;
typedef const u8 *LZSTATE[LZFX_HSIZE];

/* Define the hash function */
#define LZFX_FRST(p)     (((p[0]) << 8) | p[1])
#define LZFX_NEXT(v,p)   (((v) << 8) | p[2])
#define LZFX_IDX(h)      ((( h >> (3*8 - LZFX_HLOG)) - h  ) & (LZFX_HSIZE - 1))

/* These cannot be changed, as they are related to the compressed format. */
#define LZFX_MAX_LIT        (1 <<  5)
#define LZFX_MAX_OFF        (1 << 13)
#define LZFX_MAX_REF        ((1 << 8) + (1 << 3))

static
int lzfx_getsize(const void* ibuf, unsigned int ilen, unsigned int *olen);

/* Compressed format

    There are two kinds of structures in LZF/LZFX: literal runs and back
    references. The length of a literal run is encoded as L - 1, as it must
    contain at least one byte.  Literals are encoded as follows:

    000LLLLL <L+1 bytes>

    Back references are encoded as follows.  The smallest possible encoded
    length value is 1, as otherwise the control byte would be recognized as
    a literal run.  Since at least three bytes must match for a back reference
    to be inserted, the length is encoded as L - 2 instead of L - 1.  The
    offset (distance to the desired data in the output buffer) is encoded as
    o - 1, as all offsets are at least 1.  The binary format is:

    LLLooooo oooooooo           for backrefs of real length < 9   (1 <= L < 7)
    111ooooo LLLLLLLL oooooooo  for backrefs of real length >= 9  (L > 7)  
*/
int lzfx_compress(const void *const ibuf, const unsigned int ilen,
                              void *obuf, unsigned int *const olen){

    /* Hash table; an array of u8*'s which point
       to various locations in the input buffer */
    const u8 *htab[LZFX_HSIZE];

    const u8 **hslot;       /* Pointer to entry in hash table */
    unsigned int hval;      /* Hash value generated by macros above */
    const u8 *ref;          /* Pointer to candidate match location in input */

    const u8 *ip = (const u8 *)ibuf;
    const u8 *const in_end = ip + ilen;

    u8 *op = (u8 *)obuf;
    const u8 *const out_end = (olen == NULL ? NULL : op + *olen);

    int lit;    /* # of bytes in current literal run */

    unsigned long off;
	
    if(olen == NULL) return LZFX_EARGS;
    if(ibuf == NULL){
        if(ilen != 0) return LZFX_EARGS;
        *olen = 0;
        return 0;
    }
    if(obuf == NULL){
        if(olen != 0) return LZFX_EARGS;
        return lzfx_getsize(ibuf, ilen, olen);
    }

    memset((uint8_t *)htab, 0, sizeof(htab));

    /*  Start a literal run.  Whenever we do this the output pointer is
        advanced because the current byte will hold the encoded length. */
    lit = 0; op++;

    hval = LZFX_FRST(ip);

    while(ip + 2 < in_end){   /* The NEXT macro reads 2 bytes ahead */

        hval = LZFX_NEXT(hval, ip);
        hslot = htab + LZFX_IDX(hval);

        ref = *hslot; *hslot = ip;

        if( ref < ip
        &&  (off = ip - ref - 1) < LZFX_MAX_OFF
        &&  ip + 4 < in_end  /* Backref takes up to 3 bytes, so don't bother */
        &&  ref > (u8 *)ibuf
        &&  ref[0] == ip[0]
        &&  ref[1] == ip[1]
        &&  ref[2] == ip[2] ) {

            unsigned int len = 3;   /* We already know 3 bytes match */
            const unsigned int maxlen = in_end - ip - 2 > LZFX_MAX_REF ?
                                        LZFX_MAX_REF : in_end - ip - 2;

            /* lit == 0:  op + 3 must be < out_end (because we undo the run)
               lit != 0:  op + 3 + 1 must be < out_end */
            if(fx_expect_false(op - !lit + 3 + 1 >= out_end))
                return LZFX_ESIZE;
            
            op [- lit - 1] = lit - 1; /* Terminate literal run */
            op -= !lit;               /* Undo run if length is zero */

            /*  Start checking at the fourth byte */
            while (len < maxlen && ref[len] == ip[len])
                len++;

            len -= 2;  /* We encode the length as #octets - 2 */

            /* Format 1: [LLLooooo oooooooo] */
            if (len < 7) {
              *op++ = (off >> 8) + (len << 5);
              *op++ = off;

            /* Format 2: [111ooooo LLLLLLLL oooooooo] */
            } else {
              *op++ = (off >> 8) + (7 << 5);
              *op++ = len - 7;
              *op++ = off;
            }

            lit = 0; op++;

            ip += len + 1;  /* ip = initial ip + #octets -1 */

            if (fx_expect_false (ip + 3 >= in_end)){
                ip++;   /* Code following expects exit at bottom of loop */
                break;
            }

            hval = LZFX_FRST (ip);
            hval = LZFX_NEXT (hval, ip);
            htab[LZFX_IDX (hval)] = ip;

            ip++;   /* ip = initial ip + #octets */

        } else {
              /* Keep copying literal bytes */

              if (fx_expect_false (op >= out_end)) return LZFX_ESIZE;

              lit++; *op++ = *ip++;

              if (fx_expect_false (lit == LZFX_MAX_LIT)) {
                  op [- lit - 1] = lit - 1; /* stop run */
                  lit = 0; op++; /* start run */
              }

        } /* if() found match in htab */

    } /* while(ip < ilen -2) */

    /*  At most 3 bytes remain in input.  We therefore need 4 bytes available
        in the output buffer to store them (3 data + ctrl byte).*/
    if (op + 3 > out_end) return LZFX_ESIZE;

    while (ip < in_end) {

        lit++; *op++ = *ip++;

        if (fx_expect_false (lit == LZFX_MAX_LIT)){
            op [- lit - 1] = lit - 1;
            lit = 0; op++;
        }
    }

    op [- lit - 1] = lit - 1;
    op -= !lit;

    *olen = op - (u8 *)obuf;
    return 0;
}

/* Decompressor */
int lzfx_decompress(const void* ibuf, unsigned int ilen,
                          void* obuf, unsigned int *olen){

    u8 const *ip = (const u8 *)ibuf;
    u8 const *const in_end = ip + ilen;
    u8 *op = (u8 *)obuf;
    u8 const *const out_end = (olen == NULL ? NULL : op + *olen);
    
    unsigned int remain_len = 0;
    int rc;

    if(olen == NULL) return LZFX_EARGS;
    if(ibuf == NULL){
        if(ilen != 0) return LZFX_EARGS;
        *olen = 0;
        return 0;
    }
    if(obuf == NULL){
        if(olen != 0) return LZFX_EARGS;
        return lzfx_getsize(ibuf, ilen, olen);
    }

    do {
        unsigned int ctrl = *ip++;

        /* Format 000LLLLL: a literal byte string follows, of length L+1 */
        if(ctrl < (1 << 5)) {

            ctrl++;

            if(fx_expect_false(op + ctrl > out_end)){
                --ip;       /* Rewind to control byte */
                goto guess;
            }
            if(fx_expect_false(ip + ctrl > in_end)) return LZFX_ECORRUPT;

            do
                *op++ = *ip++;
            while(--ctrl);

        /*  Format #1 [LLLooooo oooooooo]: backref of length L+1+2
                          ^^^^^ ^^^^^^^^
                            A      B
                   #2 [111ooooo LLLLLLLL oooooooo] backref of length L+7+2
                          ^^^^^          ^^^^^^^^
                            A               B
            In both cases the location of the backref is computed from the
            remaining part of the data as follows:

                location = op - A*256 - B - 1
        */
        } else {

            unsigned int len = (ctrl >> 5);
            u8 *ref = op - ((ctrl & 0x1f) << 8) -1;

            if(len==7) len += *ip++;    /* i.e. format #2 */

            len += 2;    /* len is now #octets */

            if(fx_expect_false(op + len > out_end)){
                ip -= (len >= 9) ? 2 : 1;   /* Rewind to control byte */
                goto guess;
            }
            if(fx_expect_false(ip >= in_end)) return LZFX_ECORRUPT;

            ref -= *ip++;

            if(fx_expect_false(ref < (u8*)obuf)) return LZFX_ECORRUPT;

            do
                *op++ = *ref++;
            while (--len);
        }

    } while (ip < in_end);

    *olen = op - (u8 *)obuf;

    return 0;

guess:
    rc = lzfx_getsize(ip, ilen - (ip-(u8*)ibuf), &remain_len);
    if(rc>=0) *olen = remain_len + (op - (u8*)obuf);
    return rc;
}

/* Guess len. No parameters may be NULL; this is not checked. */
static
int lzfx_getsize(const void* ibuf, unsigned int ilen, unsigned int *olen){

    u8 const *ip = (const u8 *)ibuf;
    u8 const *const in_end = ip + ilen;
    int tot_len = 0;
    
    while (ip < in_end) {

        unsigned int ctrl = *ip++;

        if(ctrl < (1 << 5)) {

            ctrl++;

            if(ip + ctrl > in_end)
                return LZFX_ECORRUPT;

            tot_len += ctrl;
            ip += ctrl;

        } else {

            unsigned int len = (ctrl >> 5);

            if(len==7){     /* i.e. format #2 */
                len += *ip++;
            }

            len += 2;    /* len is now #octets */

            if(ip >= in_end) return LZFX_ECORRUPT;

            ip++; /* skip the ref byte */

            tot_len += len;

        }

    }

    *olen = tot_len;

    return 0;
}

// GUID_DEVCLASS_HIDCLASS
static GUID hidclass_guid = {0x745a17a0, 0x74d3, 0x11d0, {0xb6, 0xfe, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda}};

static BOOLEAN get_device_path(char *lPath, uint16_t vid, uint16_t pid, int8_t mi)
{
    const GUID *guid = &hidclass_guid;
    HidD_GetHidGuid(&hidclass_guid);
// Get device interface info set handle
// for all devices attached to system
    HDEVINFO hDevInfo = SetupDiGetClassDevs(guid, NULL, NULL,  DIGCF_PRESENT | DIGCF_DEVICEINTERFACE); // Function class devices.
    if(hDevInfo == INVALID_HANDLE_VALUE)
        return FALSE;

// Retrieve a context structure for a device interface of a device information set.
    BYTE                             buf[1024];
    PSP_DEVICE_INTERFACE_DETAIL_DATA pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)buf;
    SP_DEVICE_INTERFACE_DATA         spdid;
    SP_DEVINFO_DATA                  spdd;
    DWORD                            dwSize;
	char vidstr[64];
	char mistr[64];
	
	(void) pid; /* not used for now */
	//sprintf(vidpidstr, "vid_%04x&pid_%04x&mi_%02x", vid, pid, mi);
sprintf(vidstr, "vid_%04x&", vid);
if (mi != -1) sprintf(mistr, "&mi_%02x", mi);

	#if DEBUG == 1
printf("looking for substring %s in device path\r\n", vidstr);	
	#endif
    spdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

// Iterate through all the interfaces and try to match one based on
// the device number.    
    for(DWORD i = 0; SetupDiEnumDeviceInterfaces(hDevInfo, NULL,guid, i, &spdid); i++)
    {
    // Get the device path.
        dwSize = 0;
        SetupDiGetDeviceInterfaceDetail(hDevInfo, &spdid, NULL, 0, &dwSize, NULL);
        if(dwSize == 0 || dwSize > sizeof(buf))
            continue;
        
        pspdidd->cbSize = sizeof(*pspdidd);
        ZeroMemory((PVOID)&spdd, sizeof(spdd));
        spdd.cbSize = sizeof(spdd);
        if(!SetupDiGetDeviceInterfaceDetail(hDevInfo, &spdid, pspdidd,
                                            dwSize, &dwSize, &spdd))
            continue;
        
	#if DEBUG == 1
printf("checking path %s... ", pspdidd->DevicePath);	
	#endif
	
        /* check if the device contains our wanted vid/pid */
 //       if ( strstr( pspdidd->DevicePath, vidpidstr ) == NULL )
        if ( strstr( pspdidd->DevicePath, vidstr ) == NULL || ((mi!= -1) && strstr( pspdidd->DevicePath, mistr ) == NULL) )
        {
			#if DEBUG == 1
			printf("that's not it.\r\n");
			#endif
            continue;
        }
#if DEBUG == 1
        printf("\r\nDevice found at %s\r\n", pspdidd->DevicePath);
#endif
        //copy devpath into lPath
        strcpy(lPath, pspdidd->DevicePath);
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return TRUE;
     }
    SetupDiDestroyDeviceInfoList(hDevInfo);
    return FALSE;
}

/**
 * Initialize the g_hid_handle global variable
 * It will attempt to read paths from devicepath.dat file if it exists until it finds one which works.
 * If nothing is found, as a last resort it will try the two default paths from the Due and Leonardo
 * versions of the firmware.
 *
 * @return 0 on success, -1 on error
 */
int hid_open_device(HANDLE *device_handle, uint16_t vid, uint16_t pid, uint8_t mi){
    static uint8_t err_count = 0;
    char path[256];
	
    if (!get_device_path(path, vid, pid, mi))
    {
#if DEBUG == 1
        printf("\r\nDevice not detected (vid %04x pid %04x mi %02x).\r\n",vid,pid,mi);
#endif
        err_count++;
        if (err_count > 2){
            printf("Could not init device after multiple attempts. Exiting.\r\n");
            exit(1);
        }
        return -1;
    }
#if DEBUG == 1
        printf("\r\nDevice found (vid %04x pid %04x mi %02x).\r\n",vid,pid,mi);
#endif
    *device_handle = CreateFile(path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    
    if ( *device_handle == INVALID_HANDLE_VALUE )
    {
        printf("Could not open detected device (err = %lx).\r\n", GetLastError());
        return -1;
    }
    return 0;
}

int hid_get_report(HANDLE device_handle, uint8_t *buf, uint8_t report_id, uint8_t nb_bytes)
{
    DWORD          bytesRead = 0;
	static uint8_t tmp_buf[128];
	
	if (buf == NULL) return -1;
	
    tmp_buf[0] = report_id;

    ReadFile(device_handle, tmp_buf, nb_bytes*2, &bytesRead, NULL);
    // bytesRead should either be nb_bytes*2 (if it successfully read 2 reports) or nb_bytes (only one)
    if ( bytesRead != nb_bytes*2 && bytesRead != nb_bytes )
    {
#ifdef DEBUG
        printf("HID read error (expected %u (or twice that), but got %lu bytes)\n",nb_bytes, bytesRead);
#endif
        return -1;
    }

    /* HID read ok, copy latest report bytes */
    memcpy(buf, tmp_buf + bytesRead - nb_bytes, nb_bytes);
	
    return 0;	
}

int hid_set_report(HANDLE device_handle, const uint8_t *buf, uint8_t report_id, uint8_t nb_bytes)
{
    DWORD     bytesWritten = 0;
	uint8_t tmp_buf[128] = {0};
	
	tmp_buf[0] = report_id;
	memcpy(tmp_buf+1, buf, nb_bytes);
	
    /* send HID Report */
    WriteFile(device_handle, tmp_buf, 49, &bytesWritten, NULL); //TODO: retrieve 49 value from the device getcaps, nb_bytes+1 should work but makes chuniold crash somehow
	
#if DEBUG == 1
        printf("Wrote %lu bytes (expected %u) to report id %d. (err = %ld)\r\n", bytesWritten, nb_bytes+1, report_id, GetLastError());
#endif
	return 0; //best effort
	/*
    if ( bytesWritten == 49 ) // it always returns 49 instead of nb_bytes+1 for some reason... 
        return 0;

    return -1;
	*/
}

int hid_set_report_raw(HANDLE device_handle, const uint8_t *buf, uint8_t report_id, uint8_t nb_bytes)
{
    DWORD     bytesWritten = 0;
	
	if (buf[0] != report_id)
		return -1;
	
    /* send HID Report */
    WriteFile(device_handle, buf, nb_bytes, &bytesWritten, NULL); //TODO: retrieve 49 value from the device getcaps, nb_bytes+1 should work but makes chuniold crash somehow
	
#if DEBUG == 1
        printf("Wrote %lu bytes (expected %u) to report id %d. (err = %ld)\r\n", bytesWritten, nb_bytes+1, report_id, GetLastError());
#endif
	return 0; //best effort
	/*
    if ( bytesWritten == 49 ) // it always returns 49 instead of nb_bytes+1 for some reason... 
        return 0;

    return -1;
	*/
}


int hid_set_feature_report_raw(HANDLE device_handle, const uint8_t *buf, uint8_t report_id, uint8_t nb_bytes)
{
    DWORD     bytesWritten = 0;
	
	if (buf[0] != report_id)
		return -1;
	
    /* send HID Report */
	BOOL ret = HidD_SetFeature(device_handle, (uint8_t *)buf, nb_bytes);
	
#if DEBUG == 1
	if (ret) printf("Feature report set successfully.\n");
	else printf("Feature report failure with err = %ld\r\n", GetLastError());
#endif
	return 0; //best effort
}